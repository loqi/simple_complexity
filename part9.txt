<a title="Simple Complexity" href="http://stickybits.azurewebsites.net/?p=41">jump to beginning of series</a><a title="Simple Complexity 8" href="http://stickybits.azurewebsites.net/?p=6761"> or previous page</a>

<big>Back on page 4 regarding [math]O(n^2)[/math] I said, "little operations and fragments of operations are still operations, so in fact you are doing <em>something</em> exactly [math]n^2[/math] number of times." Attentive readers will have noticed I was playing a bit loose with my apples and oranges: "Running this algorithm against ten times more data will cause it to do about a hundred times more <em>half-compares,</em> and a hundred times more <em>tenth-of-a-swap</em> operations."
<strong>It's time I come clean with my tiny little fib.</strong>

Let's look at insertion sort:</big>

<pre>1 function insertionSort(sortArray)
2   for unsortedIndex in 1..(sortArray.length-1)
3       rCursor = unsortedIndex
4       lCursor = rCursor-1
5       element = sortArray[rCursor]
6       while rCursor > 0 and sortArray[lCursor] > element
7           sortArray[rCursor--] = sortArray[lCursor--]
8       sortArray[rCursor] = element
9   return sortArray</pre>

Like the earlier example selection sort, this code follows a triangular structure. The outer loop on line 2 considers each element except the first, walking forward to the right until it runs out of array. The inner loop at line 6 walks backward through the sorted region (everything to the left of the outer loop's index) shifting whatever it touches to the right by one position until it discovers the new home for the element. Line 8 overwrites the duplicate with the element and then the outer loop advances.

We can see that if the array is already sorted, line 7 will not run and line 8 overwrites each element with itself. If the array arrives in reverse order, the loop at line 6 iterates <em>unsortedIndex</em> number of times. This is a triangular algorithm. That is to say at most, line 7 runs once, then twice, then three times, and so on until the outer loop runs out of elements. Triangular algorithms run in [math]O(n^2)[/math] quadratic time -- same as square algorithms.

Really?

Let's look at how many times line 7 is run when sortArray arrives in reverse order. Given the input array,
these are the line numbers that run in this order.

[]              1 2 9
[12]            1 2 9
[12, 10]        1 2   3 4 5 6 7 6                           8 2 9
[12, 10, 9]     1 2   3 4 5 6 7 6   8 2   3 4 5 6 7 6 7 6   8 2 9
[12, 10, 9, 7]  1 2   3 4 5 6 7 6   8 2   3 4 5 6 7 6 7 6   8 2   3 4 5 6 7 6 7 6 7 6  8 2 9



&nbsp;
